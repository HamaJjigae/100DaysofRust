Day 1: Chapter 1, Chapter 2
Notes: cargo new (name) creates, cargo build (compiles), cargo run (runs)
**cargo check builds no exec but compile checks (super valuable and cool)**
cargo build --release makes an executable. i assume we can make an exe?

Might be worth checking out cargo docs in the future when I'm not illiterate.

Holy crap ok so theres already a ton of stuff.

use std::io; seems to be something like this:
std = standard library
** the stuff thats existing in rust (no use) is called prelude. if it isn't in prelude you need to "use" it.
io = input/output

i guess this works like import?

println!("text") calls the macro println. macros are made at compile time apparently.
**HUGE** YOU CAN DO THIS: println!("blah {}", variable); and the {} will have the variable.
this is like a formatted line, but way cleaner and more operable. so damn cool.

fn main() same as always the () is the parameters.

ok now its getting spicy.
let mut guess = String::new();

note: i already am confused by the ::

"let" creates the variable. like let idiot = "me";
but this is important. variables are standard immutable so to make it mut we need:
"mut"
so let mut idiot = "me";

ok so heres some info on :: but it doesnt really make sense to me yet.

:: means that the following is an associated function of the previous like:

hand::wave hand is the thing (or the type i guess) and then wave is the associated func.

in this case we have String as the type and new is the function that makes a new one.
im kind of curious why it has parentheses after, but i guess thats cuz its a function? i wonder what happens if i put something in there.

so after a quick chatgpt, it looks like new() is standard. but we could also use:
from("me")

so:
	let mut idiot = String::from("me"); should work

ok i found out some more stuff. so :: as an associated function makes more sense now.
it seems like each type has associated functions like new or from. but also default.

i dug into default a bit and it seems most useful for generics where you can define the trait. a trait is kinda like a way to define things associated with types (like :: associated funcs)

you also cant modify built in types like string or vec but that makes sense. anyways back to the bible i got sidetracked.

comments are made with "//" makes sense

** note ** we use "=" to make something assigned to something. not "=="

if we are using a (package? idk the correct term) like std::io, but we don't wanna "use" it for some reason. we can to std::io::associated func for io. it kinda just pulls it there without the use, but i'm not sure rn when we'd ever want this. it seems ugly.

so we have some more code here:

io::stdin()
	.read_line(&mut guess)
	.expect("Failed to read line");

stdin seems to be an associated func for io (which we imported) that has standard input.
im not sure what inputs would be non-standard but who cares for now.

.read_line seems pretty obvious, it reads a line from the input instance.
im curious what the & is and why we say that guess is mutable again.

okay so it seems that the & makes it a reference. which is different than a variable?

so when we do &mut guess. we are making a new reference called guess, and we have to makeit mut because references are immutable by default (like variables)

okay i understand it a bit more now. so read_line NEEDS a variable to modify, but more specifically it needs a reference. i dont really get rust ownership and borrowing rn but the tldr seems to be that the variable owns its own memory position. and a reference points to that variable. read_line expects a reference and therefore needs a reference in its parameter. it also has to always be mutable to modify the variable SO
read_line(&mut x) will always be the case.

this doesnt make a ton of sense rn but it will when we get to ownership i think.

typically when using methods from an instance they newline and whitespace it. makes sense

so also read_line creates a Result enum. i don't know enums super well right now but for the sake of this it looks like its kind of similar to a try catch. our .expect checks the result to ensure that it ran properly.

more on that it looks like Result can only return Ok or Err (those are its "variants").
Err also seems to contain error info which is super useful.

I'm not super clear on the syntax organization here but it looks like we are calling .expect on the Result that is returned from the method. this is super convoluted tbh.

so its like this: instance.method.resulthandling
if the method returns a "result (this is an enum)" then we need to handle it.

theres a bunch of ways but expect seems to be the basic way. this lets us unwrap (pass) if its "Ok" and print the "failed to read line" if its "Err". theres a bunch of ways to unpack error info but thats too above board for me right now and i wanna move on.

ok so expect actually CRASHES the entire damn program lmao. then it prints the string.

if you dont handle the result itll give u a warning but still compile.

lmao rust people love that little crab so much theyre calling {} crab pincers.

okay so now we need a crate. interestingly it seems that building a file is building a crate, its just a binary crate. what we want is a library crate.

when we want to use a crate we need to modify the cargo.toml to include the rand crate. this seems pretty annoying since you need the versions but itll probably just turn into a txt file that has me keep track of the versions. or use google to find the latest.

so it seems like in general we want to operate on specific versions which means i need that txt file. if you put 1.0 it will run all 1.0.1 1.0.2 etc. you can also update it with cargo if you need to for some reason.

**BIG NOTE** all crates are from crates.io amazing place to find stuff

when you build it gens a cargo lock file. that file serves as a kind of safepoint for running the file in the future if there are crate updates that break it. be careful updating since itll change the lock file.

interestingly rustanalyzer shows options for the crate. i wonder if the crate creater codes those in?

we wanna use rand::Rng so i assume the syntax is crate::associated func. interestingly the bible calls Rng a trait and not an associated func. im not sure why.

ok i get it. so associated funcs are for types only. you can use traits to define them but they arent "built-in" like type associated funcs are. everything else used in that way is a trait so the crate import uses traits not associated funcs with ::.

theres some code here that is a bit too high level for me rn but i wanna put it here anyways.

rand (the instance) :: thread_rng().gen_range(1..=100)

thread:rng gives us the thread that is local to the current execution thread, which is seeded by our OS. i have no clue what this means but ok.

ok after some research i understand threads a bit more. it seems like threads are kind of execution units that do "stuff". our main process always begins on a thread, we could call it the main thread. but then we can spawn in more threads to do other stuff. its kind of like asyncs but asyncs are nonblocking processes that happen simultaneously and don't necessarily need a new thread. you could async on a new thread tho i guess. also asyncs rely on the executor to keep running the main program. im not too worried about the semantics of this right now but it seems interesting to understand how it works. anyways back to threads, when we use thread_rng it is generating the rng value from the local thread aka the main thread. if we had two threads, the rng value would be different. also when we re-run the program the thread will be different again. there are other ways to generate rng this is just one.

finally gen_range generates based on a range expression. in this case its start...=end. im not sure if there are other range expressions but this one seems relatively simple. weird syntax though.

**BIG NOTE** if you don't know how to use a crate, just do cargo doc --open and navigate to the crate you want to understand. i assume theres also something on crates.io

okay now we have a new standard library import called cmp which is compare. this seems to be similar to comparable interface? We also get the trait Ordering from it so the syntax is:
use std::cmp::Ordering;

Ordering seems to have the variants: Less, Greater and Equal.

okay so cmp isnt comparable, it just compares comparable types i guess? i dont remember if thats the same or not.

also we can call an enums variant options like so:
Ordering(this is the enum)::Less(this is the variant)

ex match guess.cmp(&secret) dont forget this is an immutable reference to secret
	{
		Ordering::Less => println!("Too low"),
	}

now if guess.cmp creates Ordering::Less we will print Too low. 

match seems to be made of up things called arms and the syntax is match expression {arm,arm,arm}

the arms are just cases i think. always csv'd. so like case1 => expression1, etc. also last arm still ends with a comma not a semicolon.

looks like match is best for enums, but can be used for anything. btw we use _ => as a catchall for things that arent found within the match. if something happens that isnt caught its gonna not compile.

interestingly the arm checks in the match are looking for the value which is Ordering::variant. so it can check for the variant value like that which is pretty useful ngl.

apparently theres a ton of number types like i32, u32 and so on. the i means it can be positive or negative (aka it has a sign like -32). unsigned means just positive or zero cuz those don't have a sign. awkward but makes sense.

now we need to parse our input into an int. afaik all inputs are strings, its just the way it is baby. and we do it like this:

let guess: u32 = guess.trim().parse().expect("error");

i have 0 clue why its let guess : instead of let guess = but whatever.

u32 is our new type. we trim away the trailing and leading spaces and then parse it.
we also check the result type to avoid the warning and make sure it parses properly.
this would fail if it was a negative number i believe since its u32.

the bible calls this shadowing when we re-use the same variable name in type conversion. idk if it comes up in other operations but it just seems a simple name reuse here.

ok so now they say the colon after the variable name tells rust we are changing the type. the syntax here is godawful but its just the way it is. ill just have to memorize this syntax somehow.

interestingly by comparing secret and guess we are actually going to infer secret into a u32 type. i wonder if it naturally does this with all number types. ok so yeah with all number types it does type promotion setting the lower to the higher value. so u -> i 0 -> 1, etc.

so you can also add {} after an arm like arm => {}. if you do this you don't need a comma after apparently.

holy crap this code is so hard to understand but here it is:

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

so we type convert guess into u32 with :. but then we also want to use the match for the result enum from parse. so our expression has parse. and then we provide the arms for the two variants of result.

Ok also seems to contain our num value so thats how Ok(num) => num works
Err(_) is catching all error codes possible.

Day 2 Chapter 3:

so the chapter starts off talking about mutability which i already understand pretty well.
one thing thats interesting though is that the default is immutable. This is semi-standard but i think it reinforces the idea that we really want to be thinking about if we should make something mutable or not.

interestingly there are still a type called constants but they ahve to be defined seperately.
like so:
	const EXAMPLE (all caps seems to be naming convention here, with underscores obv): u32 = 10;
**Note that we have to define our type explicitly here, whereas in a variable we can just let rust figure it out**

ok so after a small dive into const vs variable vs static i found a few things out.

variable:
type is determined at compiletime
value is determined at runtime

constant:
type is determined at compiletime
value is determined at compiletime, but only certain expressions are allowed

static:
type is determined at compiletime
value is determined at runtime
NOTE, statics are global and persistent. immutable statics are threadsafe, mutables are not.

theres something here about creating a "data race" in which two threads access the same mem location and at least one is a write and theres so sync operations. this can happen with static mut and bc of that u gotta be a bit more careful with wrapping them.

theres also something called an atomic type which ive never heard of. something to look into in the future.

also found out that since rust doesnt have a garbage collector it uses drop::drop which is like a destructor in c++. p much its a deterministic way to handle stuff that goes out of scope.

shadowing seems to be a better alternative to a mutable variable. it lets us hold onto values alot better and still modify things within different scopes. it doesnt let us just arbitrarily dump values or change them without any care.

ok so i got a bit sidetracked but it looks like variables within rust are stored in a stack or a heap.
stacks are for simpler variables and heaps for more complex ones.

the reason we can shadow variables and have them keep the same name is due to how the scope places the variable on the stack (or heap). interestingly only copy types can be put on the stack due to how they are handled and due to the fact that they require little memory.

the non copytypes will be moving the data itself which removes the previous data. this is for vecs or strings for example.

oh also for heap values there will be a pointer placed within the stack.

imo shadowing seems most valuable for the stack types rather than the heap types, but still can have applications?

ok data type stuff. this is all memorization so here goes:

ints:

8bit, 16, 32, 64, 128 or arch. arch is just determined by which os ur on.

literals can use _ in place of a , to provide clarity like 3_000.

i dont know much about literals tbh but there is Decimal, Hex, Octal, Binary and Byte here. Byte can only be u8.

okay so a note here. since u8 lets us hold values from 0 to 255, if we do 256 and compile the system will panic. aka crash with an error.
however if we launch it as a release it will not panic, and instead wrap the value. so 256 would be 0 and 257 would be 1 and so on. we can handle this with the following:

Wrap it in wrapping_* methods like wrapping_add.
Return None if there is overflow with checked_* methods
Return value and boolean with overflowing_* methods
Saturate(wtv this means) at the values min or max values with saturating_* methods.

for floats we have f32 and f64 but it seems like most people use f64 for everything cuz its more precise.

because of type assumptions it acts a little weird when we do -5/3 (gives -1). bc its thinking its an int and returns an int, when we'd want a float. remainder works the same with %.

**note dont forget that we use : to set the type**

bools work exactly as expected btw.

Chars are done with single quotes not double quotes. i assume this helps the type inferrence.

ok so tuples are fixed length which we knew, but we can also define the types as such which is cool:

let tup: (i32, f64, u8) = (500, 6.4, 1);

otherwise we could let type inferrence figure it out.
tuples are defined as csvs within parentheses.

we can access the values in 1 of 2 ways (so far at least)

we can set the tup to save within a new var like:

tup = (500, 6.4, 1); this is called destructuring
let (x, y, z) = tup;

or we can just pull from the tuple as an index with:

let five_hundred = tup.0; **note we use . here to access the index which looks cool**

interestingly a blank tuple is called a "unit"

like java Arrays are also fixed length. however unlike a tuple, arrays must hold all the same type.

arrays are written like this:

let array = [1,2,3,4,5];

it seems like vecs are just better arrays but theyre on the heap rather than the stack.
however if you KNOW it will never change in length an array is better.

if you want to define the size and type of an array you do it like:

let array: [i32, 5] = [1,2,3,4,5];

you can also automate the same value across an array in such a way:

let array = [3;5]; this will make the value '3' appear 5 times in the array.

we access values from the array as like other languages with name[0] and so on.

in rust we use snake_case for function names. and we call em like functions in other languages aka
snake_case();
also we dont care where its defined as long as its within the proper scope.

ok heres some actually useful info. parameters MUST have a type definition. so it would be like this:
snake_case(x: i32) {}. 
parameters are seperated by commas so snake_case (x: i32, label: char) {}

i assume that it must be passed in the same order as is required by the fn

ok so apparently this is important:
statements perform actions and do not return a value (voids?)
expressions return a value.

this seems to stop you from doing something like x=y=6 since y=6 wouldnt have a value since its a statement.

this also means you can do something like:

let y = {
	let x = 3;
	x + 1
	};
this will make y 4 since the expression at the end is returning into the y value.

because of this, expressions dont need the ;, only statements do.

okay now its getting awkward. so if we want a return within an fn we use ->

so fn five() -> i32 {
	5
}

this returns the i32 data type value 5. it does this because it is the FINAL expression within the function.
we can also use the return keyword like in other languages to return early.

seems like the compiler will catch this, but its good to remember and think abt the differences between expressions and statements esp as it relates to syntax.

i swear like 90% of rust so far is just to make clean code and i love that.

so for 'ifs' we write it as:
if x = y {} there are no brackets like in some languages. i assume we can use them tho if we want?

ok so this is all same same but might as well write it out. if check for a bool, if it isnt a bool it panics.
you can use else to set the false arm for the if statement.

RUST WONT CONVERT NUMBERS TO BOOLS THANK GOD. SCREW YOU JS

** doesnt equal is the same syntax of !=**

rust writes else if as...drumrolllll... else if...so...

if x = y {} else if {} else if {} else {}

we should probably use match for anything over 2 else ifs

HOHO we can use conditionals when assigning variables as well thats tight.

let condition = true;
let number = if condition {5} else {6};

however these two options must be the same type. probs due to how it does type inferrence.

3 kinds of loops: loop, for, while

loops are infinite and need to be broken written like:
loop {}

interestingly the loop can return a value on the break

let mut counter = 0;

let result = loop { counter += 1; if counter == 10 { break counter * 2; } };

this would return 20 from the loop to the value for result. (need the semicolon to make it a statement)

**note that break only exists the current loop, return exits the function**

we can create loop labels with the format 'name . so like 'counting_loop: loop {}.
this lets us do targeted breaks with break 'counting_loop;

while loops similarly to ifs are just like:
while true {}

kind of like java we can do a for loop that sets a variable such as:

let array = [1,2,3,4,5]

for element in array {}

you can also do in ranges like 1..4 or reverse it with 1..4.rev()

ok now im gonna work on the recommended projects for my remaining time.

convering fahrenheit and celcius
generate the nth fibonacci number
print the lyrics to the christmas carol 'the twelve days of christmas'

okay so i made an option select for the programs but havent started working on the programs themselves yet.

i found out that as long as a type has a FromStr method you can do something like:

match string.trim().parse::<u32>() {} instead of let string : u32 = string.trim().parse().expect(). which is nice.

ngl this was so convoluted to even do this simple thing but im sure itll become easier.


Day 3:

Had a bit less time today so just wanted to work on the programs. I found out a few new things that seem very useful.

1. Option is an enum that is either Some(T) or None. So its either some value or nothing.

2. Recursion is so awful for repetitive calls, BUT we can do something called memoisation to hold onto old recursions. this is kind of like how we use hashmaps for 3sum.

3. The fibonacci sequence ramps up really quick.

4. By using u over i for int parses, we can actually check for negatives with Err(_).

My fibonacci code kept getting cooked with high numbers due to memory restrictions but also performance so i had to look up the way to code it properly. because of this, i wanted to include my understanding of how the code works below as its not really my code.

so we want to use HashMaps to store and check the values of each iteration of the fib fn as it will call the same values over and over. we do this by storing it in the memo hashmap and passing that HashMap to the next recursion as well. this means we are constantly updating the hashmap with the values for each N, and then checking them with Option::Some.aka if they exist we don't recalc them. this saves a ton of time and stops our pcs from taking off.

this is just a word thing, but this is just caching right? we're caching our values and then checking them.

kind of a cool way to do it with if let Some(&result) = memo.get(&n)

this means we can put a conditional on the Option::Some enum that we get from .get

turns out that fixed length collections don't return option, but variable length like vecs or HashMaps give us back an Option enum from .get since they can return something but aren't "guaranteed" to.

also if let Some(&result) = memo.get(&n) is just a lowlevel way of saying if memo.get.exists but with destructuring to handle the references from n to result.

im gonna call it right now ownership is going to make my head spin off my shoulders for a long time.

OK THIS IS SO CONFUSING RN IM SURE ITLL MAKE SENSE IN THE FUTURE BUT & BOTH REFERENCES AND DEREFERENCES STUFF. HOW DOES THAT MAKE SENSE.

so this line: let Some(&result) = memo.get(&n)

does all of this:
1. memo does not want us to have ownership of the values it has, since its a greedy bastard. (this is also for performance and safety)
2. .get returns an Option enum kind of. since we are using references (&n) we don't technically have the value, but we have a reference to that value. so the option enum is also going to contain the value within a reference.
3. So now we have a fork where its either Some(reference) or None (this is just null)
4. With our logic it only continues when it is Some, but our Some is a reference value which isn't really that useful for computations.
5. So we DEREFERENCE our reference with &result, which gives us the value from .get without actually taking ownership away from the hashmap.

working with ints in rust is definitely interesting since you can overflow so quickly. even a u128 caps out really quickly in rust, and it makes me want to use BigInt crates. its just so unecessary for this project. i learned a ton about matching and handling parses but tbh i feel like ill forget all this syntax by tomorrow. itll take time and im really enjoying the process so far. i hope i become a good rust coder.

Day 4:

I ended up taking a huge break from this project due to some life stuff, but I am back and hopefully consistent. The goal for now is to start doing 2 "Days" per day to catch up on lost time. This is all within the realm that I can actually understand what I am learning. Today is chapter 4: Ownership.

So they briefly discuss stack and heap here, 1 thing to note is that the data stored on the stack must have a known size (like an array). but data on the heap does not (like a vec). It seems like there's something called an 'allocator' that kind of works like an usher at church. It tries to find memory within the heap to fit you.

Here are some basic rules for ownership:
1. each value in rust has an owner
2. there can only be one owner at a time
3. if it goes out of scope, the value is dropped

.push_str("text"); adds text to the end of a mutable string

so a string literal (&str) is a hardcoded value stored at compiletime, a String is mutable and can grow and shink at runtime.

so unlike C where we need to allocate a variable and then free it, rust returns the memory as soon as a variable is out of scope. this means scope is really important in rust.

AHA here is drop. i knew theyd mention it eventually. p much when a var goes out of scope it calls drop on the var.

okay so copying data on the stack is easy you can just copy it as normal. but if you do something like:

let s1 = String::from("world");
let s2 = s1;

what will happen is s1 will now be invalidated, and s2 will have the pointer, capacity and length of s1. in simple terms it becomes the new owner of that memory.

rust calls this 'moving' rather than 'copying' to differentiate between the two.

to 'copy' a string we must instead .clone it. which is quite performance intensive due to how we handle heap values

if we do something like:

let mut s = String::from("world");
s = String::from("ahoy");

println!("{s}, world!");

it will invalidate or remove the pointer to world and instead set a completely new pntr length and capacity for ahoy. the pointer and capacity and length for world will now be freed and will be 'collected' by drop.

a few notes here about copy and clone, since we know that copy needs the information to be on the stack and not a pointer, we can only copy scalar values like int, bool, char, float, etc.

we can copy arrays and tuples BUT the datatypes within them must also be scalar. aka an array of [1,2,3] is copyable but ['x', 'y'] is not since a string is not scalar. For vecs, since they aren't scalar at all, we can't copy them ever.

okay so some things that can screw us up are here. if we pass a String into a function, we are giving it ownership of that value. that means in the current scope the variable is now out of scope. To keep that value inside of the current scope (not the function scope) we have to clone it first before passing it into the function.

this isnt used rn but the dereferencing operator is *

references can be mutable which allows any operation to be performed on the reference as long as it does not require ownership. aka a &mut String can be .push_str'd

one thing about mutable references is there can only be one at a time.

okay i got a little sidetracked here but i found out something about threads called thread pools. rayon (which is a prelude method? crate? idk) allows us to create a thread pool which queues actions that exceed the maximum threads for parallelism. so if we have 10 tasks and 4 threads itll do 4 tasks, and as soon as one thread finishes, task 5 will start and so on.

data races happen because of the following:

Two or more pointers accessing the same data at the same time
At least one of the pointers is being used to write to the data
Theres no mechanism to synchronise the data

interestingly you can create a block scope which is a scope with no identifier. this can be used to end mut references and many other things. seems pretty useful.

similarly as mentioned before, like how we can't have two mutable references, we also cant have an immutable reference and a mutable reference to the same thing existing at the same time.

there is a bit of a variance here where an immutable reference is only 'active' or 'in scope' when it is being used

if it stops being used, it stops being active. and then we could for instance set a mutable reference. however, if we use the immutable reference after we try and set the mutable reference it will cause an error since the immutable reference is still active.

okay so slices here are a really important type and they seem very powerful. pretty much it allows us to return part of a collection, rather than the entire collection. Also its a reference so it doesnt have ownership.

few small things here, to iterate over a string letter by letter we turn it into bytes using string.as_bytes();

then we can use .iter() to iterate over the array of bytes.

okay this is big and i have no clue how i didnt know this. each letter has an ASCII value associated with it. so 'h' is 104. this means .as_bytes can be used for cryptography. very sick.

.enumerate() wraps the results of .iter() and presumably other things, and returns it as a tuple.

not that b'' is a byte literal, but '' is a char literal.

we create slices within a range by doing this:

let s = String::from("hello world");

let hello = &s[0..5];

this format is &(reference) [starting index...ending index]; to make a slice

a note for rust's range syntax, if ur starting at index 0 you can just drop the 0 and go [..5]

similarly if it goes to the end it can just be [5..]

combining those this is valid: s&[..];

**NOTE slice range indices must be at valid UTF-8 character boundaries** idk what this means but lets just leave it here for now.

&str would return a string slice for instance if it has a range.

note here that &str which is a string literal is actually a reference to a slice. at compiletime the string is turned into binary and we slice that to provide our value. so &str is a reference to a slice of binary.

you can also use &str to kind of cover your ass for &String and &str since &str is a slice already this is something called deref coercion which i don't really get yet but its covered in ch15 or somethin.

OKAY CHAPTER 5 FOR LIKE 12MINS.

Structs. I know you use Structs/enums to do something similar to OOP so this will be interesting.

Okay so structs kind of work like attributes in OOP allowing us to do something like this:

struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

however once important note on the wording is that these are called 'fields' and not 'attributes'

this kind of works like an abstract constructor where we are given these fields but still have to fill them out:

fn main() {
	let user1 = User {
		active: true,
		username: String::from("example123"),
		email: String::from("example@example.com"),
		sign_in_count: 1,
	};
}

a few notes here: a field can be set as optional with Option<data type>
	also a field can be filled with the default value for that data type with ..Default::default.

HOWEVER you cannot define a default value in the struct itself.

we can get the value from a field with dot notation like user1.email
we could also change the value of the field assuming user1 is mut with user1.email = String::from("change");

however for this to work the entire instance must be mutable, not just the field.

we can also make a fn like this that kind of automates the active status and sign_in_count:

fn build_user(email: String, username: String) -> User {
	User {
		active: true,
		username: username,
		email: email,
		sign_in_count: 1,
	}
}

this means that we can just pass in email and username and get a new user like that.

ALSO if the parameter and the field have the same name aka email: email, we can just write, email on that line and it works properly. this means double-naming actually helps us here.

we can also steal the values from another instance very efficiently with .. such as:

let user2 = User {
		email: String::from("anotheruser@example.com")
		..user1
	};

this would be a very efficient way to copy data. but for now that's my time. ONWARDS AND UPWARDS TOMORROW RAH.

Day 5:

okay it is definitely not 'tomorrow' but we press on. i think we are on structs. should finish this + enums today maybe?

like 0% chance we actually get to code anything today right? im thinking that after we get through chapter 8 common collections we start to work on our cli and then return to studying. ah shit ok nvm theres literally a chapter on cli LOL. ok we have to get to chapter 12. so 5/6 today. 7 and MAYBE 8 tomorrow. 9/10 seem fast. then 11 and some of 12. then we finish 12 and work on cli. cli probs takes like 3-5 days ish? since ive decided to pivot from OS dev to blockchain we need to really be studying some blockchain so after the cli we slam it to 20 and then full-send blockchain studying. ideally within the zk snark project of groth 16 1-1 -> halo2 1-1 -> halo2 m-1. then some final zk snark/crypto project for the portfolio then im off to the races.

ok so tuple structs are used to group values under a particular name without needing fields. they are just kind of like a container. the values are also grouped under the custom type defined by the tuple struct's name. each struct you make is its own 'type' right. you can also index these.

you can also make a unit-like struct that doesn't have any fields at all. this is useful mainly for implementing traits on a type.

its written like this btw:

struct TestTester;

no parentheses or curlies.

ok so when making structs you normally want to use standard Strings so that they own the values and are valid while the struct is valid. however you can use &str slices or any other kind of reference as long as you define its 'lifetime'. lifetimes are things covered later, but good to know they exist for now.

okay so here we have an example program. ill write it out to keep up.

fn main() {
	let width1 = 30;
	let height1 = 50;

	println!(
		"The area of the rectangle is {} square pixels.",
		area(width1, height1)
	);
}

fn area(width: u32, height: u32) -> u32 { width * height }

we can convert this into a standard tuple by combining width and height into

let rect1 = (30, 50);

and fn area is -> fn area(dimensions: (u32, u32)) -> u32 { dimensions.0 * dimensions.1 }

now we can use a struct here to define Rectangle which is much clearer:

struct Rectangle {
	width: u32,
	height: u32,
}

fn main() {
	let rect1 = Rectangle {
		width: 30,
		height: 50,
	};

	println!(
		"The area of the rectangle is {} square pixels.",
		area(&rect1)
	);
}

fn area(rectangle: &Rectangle) -> u32 {rectangle.width * rectangle.height }

^^^^^^^^ this is legit just OOP but much cleaner.
Note that when we send rect1 to fn area we use a reference since we wanna keep ownership within the struct.

so some notes here: if we add {:?} inside the curly braces it uses an output format called 'debug'.
debug trait enables us to print out struct in a way thats useful for devs so we can see its value.

to make this work we need to add #[derive(Debug)] to our struct. damn rustc is actually so helpful lmao. the error text is nuts

with larger structs you can also use {:#?} which formats it into a new line for each field.

you can also use dbg! instead of println! but some notes on this. 1. it prints to stderr not stdout. we can also set dbg! in the field itself like so:

width: dbg!(30 * scale),

ok so now we have methods (THIS IS JUST OOP LOL). methods are defined with fn (just like a func), but exist within the context of a struct, enum or trait object.

heres the full code:

#[derive(Debug)]
struct Rectangle {
	width: u32,
	height: u32,
}

impl Rectangle {
	fn area(&self) -> u32 {
		self.width * self.height
	}
}

fn main () {
	let rect1 = Rectangle {
		width: 30,
		height: 50,
	};

	println!(
		"The area of the rectangle is {} square pixels.",
		rect1.area()
	);
}

so to start with we have an impl (implementation block). this turns the fn to a method within the context of the struct. then we ensure the method has &self,
since the parameter typically utilizes self in a method. then when we reference area we can use it as a method syntax such as rect1.area().

within the impl block, the type 'Self' refers as an alias to the type that the impl block is for. in this case, Rectangle.
Typically we call self with &self as a reference. we can sometimes use &mut self and RARELY we use just self. this would only be used when the method transforms self, and we want to prevent the caller from using the original instance.

typically when a method has the same name as a field like:

impl Rectangle {
	fn width(&self) -> u32 {
		self.width
	}
}

we use this as a 'getter'.

note that automatic referencing occurs in methods which keeps code cleaner and removes the need to set mut values on references.

ok now we want some kind of method that checks if it can fit inside anothe rectangle. im gonna try and code this myself.

struct Rectangle {
	width: u32,
	height: u32,
}

impl Rectangle {
	fn can_fit(&self, other: Rectangle) {
		if self.height > other.height && self.width > other.width {
			true
		}
		else { false }
	}
}

something like that?? ok i forgot &Rectangle instead of Rectangle. you can also make it WAY cleaner with the bool setup.

impl Rectangle {
	fn can_fit(&self, other: Rectangle) -> bool {
		self.height > other.height && self.width > other.width {
	}
}

if we don't have self as the first parameter it isnt a method, its an associated function. a very standard way of doing this is with constructors (which we set to the name 'new')

it would be something like this:

impl Rectangle {
	fn square(size: u32) -> Self {
		Self {
			width: size,
			height: size,
		}
	}
}

To call this associated fun we use :: like 

let sq = Rectangle::square(3);. 

also we can have multiple impl blocks. we will find out why thats ever useful in ch10 apparently. dude ch10 has so much lmao.

ok its only been about an hour and id really like to do enums as well but i should sleep. my focus timer also bugged out so its a sign.

Day 6:

Gonna do a short little session on enums today since I've been really bad on this project. Gonna do smaller sessions to try and build good habits.

okay so each enum value can only be one variant or another. it cant be both. so its useful for more selective properties rather than shared properties like a struct would have. mutually exclusive.

you can reference the enum like so:
enum IpAddrKind {
	V4,
	V6,
}

let four = IpAddrKind::V4;
let six = IpAddrKind::V6;

then we can use it in a fn like so:

fn route(ip_kind: IpAddrKind() {}

route(IpAddrKind::V4);

you could use a struct to set a 'kind' and 'address' associations but it makes more sense to do it through a pairing within the enum:


enum IpAddr {
	V4(String),
	V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));

this means that the IpAddr enum has an associated string value.

you can also do differentiation as such:

enum IpAddr {
	V4(u8, u8, u8, u8),
	V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);
let loopback = IpAddr::V6(String::from("::1"));

theres also a std lib for IpAddr, but it sets address data inside a struct:

struct Ipv4Addr {}
struct Ipv6Addr {}

enum IpAddr {
	V4(Ipv4Addr),
	V6(Ipv6Addr),
}

so you can really put any type of data within an enum variant, strings, types, structs or even another enum. so like...cascading enums?

im really interested in learning about vecs but holy god the syntax looks so awful lmao

oooh you can have named values in an enum as well like:

enum Message {
	Quit,
	Move { x: i32, y: i32 }.
}

so afaik, match lets you (forces you) to access all the points in an enum (above would be quit and move). if let accesses one (so just move, or even just x), or you can use a fn to do some kind of custom return.

Enums also don't 'sort' values into the respective enum. rather they have to be explicitly cast into the correct enum. you could always add handling in an outside block.

okay now we have the std::Option
OH IS THIS SOME() NONE()??

interesting that Rust actually doesn't have null. i guess its just None?

okay its defined as:

enum Option<T> {
	None,
	Some(T),
}

oh its not even std::Option. its legit a prelude that makes sense ngl cuz nulls are pervasive.

example:

let some_number = Some(5);
let some_char = Some('e');

let absent_number: Option<i32> = None;

so some_number would be Option<i32> (i guess thats the default. apprently i32 is the default for all ints in rust)

we can also define a type for None, corresponding to that variable. so absent_number would be Option<i32>

However you cant do this:

let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y;

this is because Option<i8> isn't actually a value. its an enum reference. we need to extract that value if we want to use it.

okay im done with 6.1 today. ill do 6.2 and maybe 6.3 tomorrow who knows.

Day 7:

Day 8:

Day 9:

Day 10:

Day 11:

Day 12:

Day 13:

Day 14:

Day 15:

Day 16:

Day 17:

Day 18:

Day 19:

Day 20:

Day 21:

Day 22:let mut s = String::from("world");
s = String::from("ahoy");

println!("{s}, world!");

it will invalidate or remove the pointer to world and instead set a completely new pntr length and capacity for ahoy. the pointer and capacity and length for world will now be invalidated and will be 'collected' by drop.


Day 23:

Day 24:

Day 25:

Day 26:

Day 27:

Day 28:

Day 29:

Day 30:

Day 31:

Day 32:

Day 33:

Day 34:

Day 35:

Day 36:

Day 37:

Day 38:

Day 39:

Day 40:

Day 41:

Day 42:

Day 43:

Day 44:

Day 45:

Day 46:

Day 47:

Day 48:

Day 49:

Day 50:

Day 51:

Day 52:

Day 53:

Day 54:

Day 55:

Day 56:

Day 57:

Day 58:

Day 59:

Day 60:

Day 61:

Day 62:

Day 63:

Day 64:

Day 65:

Day 66:

Day 67:

Day 68:

Day 69:

Day 70:

Day 71:

Day 72:

Day 73:

Day 74:

Day 75:

Day 76:

Day 77:

Day 78:

Day 79:

Day 80:

Day 81:

Day 82:

Day 83:

Day 84:

Day 85:

Day 86:

Day 87:

Day 88:

Day 89:

Day 90:

Day 91:

Day 92:

Day 93:

Day 94:

Day 95:

Day 96:

Day 97:

Day 98:

Day 99:

Day 100:
