Day 1: Chapter 1, Chapter 2
Notes: cargo new (name) creates, cargo build (compiles), cargo run (runs)
**cargo check builds no exec but compile checks (super valuable and cool)**
cargo build --release makes an executable. i assume we can make an exe?

Might be worth checking out cargo docs in the future when I'm not illiterate.

Holy crap ok so theres already a ton of stuff.

use std::io; seems to be something like this:
std = standard library
** the stuff thats existing in rust (no use) is called prelude. if it isn't in prelude you need to "use" it.
io = input/output

i guess this works like import?

println!("text") calls the macro println. macros are made at compile time apparently.
**HUGE** YOU CAN DO THIS: println!("blah {}", variable); and the {} will have the variable.
this is like a formatted line, but way cleaner and more operable. so damn cool.

fn main() same as always the () is the parameters.

ok now its getting spicy.
let mut guess = String::new();

note: i already am confused by the ::

"let" creates the variable. like let idiot = "me";
but this is important. variables are standard immutable so to make it mut we need:
"mut"
so let mut idiot = "me";

ok so heres some info on :: but it doesnt really make sense to me yet.

:: means that the following is an associated function of the previous like:

hand::wave hand is the thing (or the type i guess) and then wave is the associated func.

in this case we have String as the type and new is the function that makes a new one.
im kind of curious why it has parentheses after, but i guess thats cuz its a function? i wonder what happens if i put something in there.

so after a quick chatgpt, it looks like new() is standard. but we could also use:
from("me")

so:
	let mut idiot = String::from("me"); should work

ok i found out some more stuff. so :: as an associated function makes more sense now.
it seems like each type has associated functions like new or from. but also default.

i dug into default a bit and it seems most useful for generics where you can define the trait. a trait is kinda like a way to define things associated with types (like :: associated funcs)

you also cant modify built in types like string or vec but that makes sense. anyways back to the bible i got sidetracked.

comments are made with "//" makes sense

** note ** we use "=" to make something assigned to something. not "=="

if we are using a (package? idk the correct term) like std::io, but we don't wanna "use" it for some reason. we can to std::io::associated func for io. it kinda just pulls it there without the use, but i'm not sure rn when we'd ever want this. it seems ugly.

so we have some more code here:

io::stdin()
	.read_line(&mut guess)
	.expect("Failed to read line");

stdin seems to be an associated func for io (which we imported) that has standard input.
im not sure what inputs would be non-standard but who cares for now.

.read_line seems pretty obvious, it reads a line from the input instance.
im curious what the & is and why we say that guess is mutable again.

okay so it seems that the & makes it a reference. which is different than a variable?

so when we do &mut guess. we are making a new reference called guess, and we have to makeit mut because references are immutable by default (like variables)

okay i understand it a bit more now. so read_line NEEDS a variable to modify, but more specifically it needs a reference. i dont really get rust ownership and borrowing rn but the tldr seems to be that the variable owns its own memory position. and a reference points to that variable. read_line expects a reference and therefore needs a reference in its parameter. it also has to always be mutable to modify the variable SO
read_line(&mut x) will always be the case.

this doesnt make a ton of sense rn but it will when we get to ownership i think.

typically when using methods from an instance they newline and whitespace it. makes sense

so also read_line creates a Result enum. i don't know enums super well right now but for the sake of this it looks like its kind of similar to a try catch. our .expect checks the result to ensure that it ran properly.

more on that it looks like Result can only return Ok or Err (those are its "variants").
Err also seems to contain error info which is super useful.

I'm not super clear on the syntax organization here but it looks like we are calling .expect on the Result that is returned from the method. this is super convoluted tbh.

so its like this: instance.method.resulthandling
if the method returns a "result (this is an enum)" then we need to handle it.

theres a bunch of ways but expect seems to be the basic way. this lets us unwrap (pass) if its "Ok" and print the "failed to read line" if its "Err". theres a bunch of ways to unpack error info but thats too above board for me right now and i wanna move on.

ok so expect actually CRASHES the entire damn program lmao. then it prints the string.

if you dont handle the result itll give u a warning but still compile.

lmao rust people love that little crab so much theyre calling {} crab pincers.

okay so now we need a crate. interestingly it seems that building a file is building a crate, its just a binary crate. what we want is a library crate.

when we want to use a crate we need to modify the cargo.toml to include the rand crate. this seems pretty annoying since you need the versions but itll probably just turn into a txt file that has me keep track of the versions. or use google to find the latest.

so it seems like in general we want to operate on specific versions which means i need that txt file. if you put 1.0 it will run all 1.0.1 1.0.2 etc. you can also update it with cargo if you need to for some reason.

**BIG NOTE** all crates are from crates.io amazing place to find stuff

when you build it gens a cargo lock file. that file serves as a kind of safepoint for running the file in the future if there are crate updates that break it. be careful updating since itll change the lock file.

interestingly rustanalyzer shows options for the crate. i wonder if the crate creater codes those in?

we wanna use rand::Rng so i assume the syntax is crate::associated func. interestingly the bible calls Rng a trait and not an associated func. im not sure why.

ok i get it. so associated funcs are for types only. you can use traits to define them but they arent "built-in" like type associated funcs are. everything else used in that way is a trait so the crate import uses traits not associated funcs with ::.

theres some code here that is a bit too high level for me rn but i wanna put it here anyways.

rand (the instance) :: thread_rng().gen_range(1..=100)

thread:rng gives us the thread that is local to the current execution thread, which is seeded by our OS. i have no clue what this means but ok.

ok after some research i understand threads a bit more. it seems like threads are kind of execution units that do "stuff". our main process always begins on a thread, we could call it the main thread. but then we can spawn in more threads to do other stuff. its kind of like asyncs but asyncs are nonblocking processes that happen simultaneously and don't necessarily need a new thread. you could async on a new thread tho i guess. also asyncs rely on the executor to keep running the main program. im not too worried about the semantics of this right now but it seems interesting to understand how it works. anyways back to threads, when we use thread_rng it is generating the rng value from the local thread aka the main thread. if we had two threads, the rng value would be different. also when we re-run the program the thread will be different again. there are other ways to generate rng this is just one.

finally gen_range generates based on a range expression. in this case its start...=end. im not sure if there are other range expressions but this one seems relatively simple. weird syntax though.

**BIG NOTE** if you don't know how to use a crate, just do cargo doc --open and navigate to the crate you want to understand. i assume theres also something on crates.io

okay now we have a new standard library import called cmp which is compare. this seems to be similar to comparable interface? We also get the trait Ordering from it so the syntax is:
use std::cmp::Ordering;

Ordering seems to have the variants: Less, Greater and Equal.

okay so cmp isnt comparable, it just compares comparable types i guess? i dont remember if thats the same or not.

also we can call an enums variant options like so:
Ordering(this is the enum)::Less(this is the variant)

ex match guess.cmp(&secret) dont forget this is an immutable reference to secret
	{
		Ordering::Less => println!("Too low"),
	}

now if guess.cmp creates Ordering::Less we will print Too low. 

match seems to be made of up things called arms and the syntax is match expression {arm,arm,arm}

the arms are just cases i think. always csv'd. so like case1 => expression1, etc. also last arm still ends with a comma not a semicolon.

looks like match is best for enums, but can be used for anything. btw we use _ => as a catchall for things that arent found within the match. if something happens that isnt caught its gonna not compile.

interestingly the arm checks in the match are looking for the value which is Ordering::variant. so it can check for the variant value like that which is pretty useful ngl.

apparently theres a ton of number types like i32, u32 and so on. the i means it can be positive or negative (aka it has a sign like -32). unsigned means just positive or zero cuz those don't have a sign. awkward but makes sense.

now we need to parse our input into an int. afaik all inputs are strings, its just the way it is baby. and we do it like this:

let guess: u32 = guess.trim().parse().expect("error");

i have 0 clue why its let guess : instead of let guess = but whatever.

u32 is our new type. we trim away the trailing and leading spaces and then parse it.
we also check the result type to avoid the warning and make sure it parses properly.
this would fail if it was a negative number i believe since its u32.

the bible calls this shadowing when we re-use the same variable name in type conversion. idk if it comes up in other operations but it just seems a simple name reuse here.

ok so now they say the colon after the variable name tells rust we are changing the type. the syntax here is godawful but its just the way it is. ill just have to memorize this syntax somehow.

interestingly by comparing secret and guess we are actually going to infer secret into a u32 type. i wonder if it naturally does this with all number types. ok so yeah with all number types it does type promotion setting the lower to the higher value. so u -> i 0 -> 1, etc.

so you can also add {} after an arm like arm => {}. if you do this you don't need a comma after apparently.

holy crap this code is so hard to understand but here it is:

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

so we type convert guess into u32 with :. but then we also want to use the match for the result enum from parse. so our expression has parse. and then we provide the arms for the two variants of result.

Ok also seems to contain our num value so thats how Ok(num) => num works
Err(_) is catching all error codes possible.

Day 2 Chapter 3:

so the chapter starts off talking about mutability which i already understand pretty well.
one thing thats interesting though is that the default is immutable. This is semi-standard but i think it reinforces the idea that we really want to be thinking about if we should make something mutable or not.

interestingly there are still a type called constants but they ahve to be defined seperately.
like so:
	const EXAMPLE (all caps seems to be naming convention here, with underscores obv): u32 = 10;
**Note that we have to define our type explicitly here, whereas in a variable we can just let rust figure it out**

ok so after a small dive into const vs variable vs static i found a few things out.

variable:
type is determined at compiletime
value is determined at runtime

constant:
type is determined at compiletime
value is determined at compiletime, but only certain expressions are allowed

static:
type is determined at compiletime
value is determined at runtime
NOTE, statics are global and persistent. immutable statics are threadsafe, mutables are not.

theres something here about creating a "data race" in which two threads access the same mem location and at least one is a write and theres so sync operations. this can happen with static mut and bc of that u gotta be a bit more careful with wrapping them.

theres also something called an atomic type which ive never heard of. something to look into in the future.

also found out that since rust doesnt have a garbage collector it uses drop::drop which is like a destructor in c++. p much its a deterministic way to handle stuff that goes out of scope.

shadowing seems to be a better alternative to a mutable variable. it lets us hold onto values alot better and still modify things within different scopes. it doesnt let us just arbitrarily dump values or change them without any care.

ok so i got a bit sidetracked but it looks like variables within rust are stored in a stack or a heap.
stacks are for simpler variables and heaps for more complex ones.

the reason we can shadow variables and have them keep the same name is due to how the scope places the variable on the stack (or heap). interestingly only copy types can be put on the stack due to how they are handled and due to the fact that they require little memory.

the non copytypes will be moving the data itself which removes the previous data. this is for vecs or strings for example.

oh also for heap values there will be a pointer placed within the stack.

imo shadowing seems most valuable for the stack types rather than the heap types, but still can have applications?

ok data type stuff. this is all memorization so here goes:

ints:

8bit, 16, 32, 64, 128 or arch. arch is just determined by which os ur on.

literals can use _ in place of a , to provide clarity like 3_000.

i dont know much about literals tbh but there is Decimal, Hex, Octal, Binary and Byte here. Byte can only be u8.

okay so a note here. since u8 lets us hold values from 0 to 255, if we do 256 and compile the system will panic. aka crash with an error.
however if we launch it as a release it will not panic, and instead wrap the value. so 256 would be 0 and 257 would be 1 and so on. we can handle this with the following:

Wrap it in wrapping_* methods like wrapping_add.
Return None if there is overflow with checked_* methods
Return value and boolean with overflowing_* methods
Saturate(wtv this means) at the values min or max values with saturating_* methods.

for floats we have f32 and f64 but it seems like most people use f64 for everything cuz its more precise.

because of type assumptions it acts a little weird when we do -5/3 (gives -1). bc its thinking its an int and returns an int, when we'd want a float. remainder works the same with %.

**note dont forget that we use : to set the type**

bools work exactly as expected btw.

Chars are done with single quotes not double quotes. i assume this helps the type inferrence.

ok so tuples are fixed length which we knew, but we can also define the types as such which is cool:

let tup: (i32, f64, u8) = (500, 6.4, 1);

otherwise we could let type inferrence figure it out.
tuples are defined as csvs within parentheses.

we can access the values in 1 of 2 ways (so far at least)

we can set the tup to save within a new var like:

tup = (500, 6.4, 1); this is called destructuring
let (x, y, z) = tup;

or we can just pull from the tuple as an index with:

let five_hundred = tup.0; **note we use . here to access the index which looks cool**

interestingly a blank tuple is called a "unit"

like java Arrays are also fixed length. however unlike a tuple, arrays must hold all the same type.

arrays are written like this:

let array = [1,2,3,4,5];

it seems like vecs are just better arrays but theyre on the heap rather than the stack.
however if you KNOW it will never change in length an array is better.

if you want to define the size and type of an array you do it like:

let array: [i32, 5] = [1,2,3,4,5];

you can also automate the same value across an array in such a way:

let array = [3;5]; this will make the value '3' appear 5 times in the array.

we access values from the array as like other languages with name[0] and so on.

in rust we use snake_case for function names. and we call em like functions in other languages aka
snake_case();
also we dont care where its defined as long as its within the proper scope.

ok heres some actually useful info. parameters MUST have a type definition. so it would be like this:
snake_case(x: i32) {}. 
parameters are seperated by commas so snake_case (x: i32, label: char) {}

i assume that it must be passed in the same order as is required by the fn

ok so apparently this is important:
statements perform actions and do not return a value (voids?)
expressions return a value.

this seems to stop you from doing something like x=y=6 since y=6 wouldnt have a value since its a statement.

this also means you can do something like:

let y = {
	let x = 3;
	x + 1
	};
this will make y 4 since the expression at the end is returning into the y value.

because of this, expressions dont need the ;, only statements do.

okay now its getting awkward. so if we want a return within an fn we use ->

so fn five() -> i32 {
	5
}

this returns the i32 data type value 5. it does this because it is the FINAL expression within the function.
we can also use the return keyword like in other languages to return early.

seems like the compiler will catch this, but its good to remember and think abt the differences between expressions and statements esp as it relates to syntax.

i swear like 90% of rust so far is just to make clean code and i love that.

so for 'ifs' we write it as:
if x = y {} there are no brackets like in some languages. i assume we can use them tho if we want?

ok so this is all same same but might as well write it out. if check for a bool, if it isnt a bool it panics.
you can use else to set the false arm for the if statement.

RUST WONT CONVERT NUMBERS TO BOOLS THANK GOD. SCREW YOU JS

** doesnt equal is the same syntax of !=**

rust writes else if as...drumrolllll... else if...so...

if x = y {} else if {} else if {} else {}

we should probably use match for anything over 2 else ifs

HOHO we can use conditionals when assigning variables as well thats tight.

let condition = true;
let number = if condition {5} else {6};

however these two options must be the same type. probs due to how it does type inferrence.

3 kinds of loops: loop, for, while

loops are infinite and need to be broken written like:
loop {}

interestingly the loop can return a value on the break

let mut counter = 0;

let result = loop { counter += 1; if counter == 10 { break counter * 2; } };

this would return 20 from the loop to the value for result. (need the semicolon to make it a statement)

**note that break only exists the current loop, return exits the function**

we can create loop labels with the format 'name . so like 'counting_loop: loop {}.
this lets us do targeted breaks with break 'counting_loop;

while loops similarly to ifs are just like:
while true {}

kind of like java we can do a for loop that sets a variable such as:

let array = [1,2,3,4,5]

for element in array {}

you can also do in ranges like 1..4 or reverse it with 1..4.rev()

ok now im gonna work on the recommended projects for my remaining time.

convering fahrenheit and celcius
generate the nth fibonacci number
print the lyrics to the christmas carol 'the twelve days of christmas'

okay so i made an option select for the programs but havent started working on the programs themselves yet.

i found out that as long as a type has a FromStr method you can do something like:

match string.trim().parse::<u32>() {} instead of let string : u32 = string.trim().parse().expect(). which is nice.

ngl this was so convoluted to even do this simple thing but im sure itll become easier.


Day 3:

Had a bit less time today so just wanted to work on the programs. I found out a few new things that seem very useful.

1. Option is an enum that is either Some(T) or None. So its either some value or nothing.

2. Recursion is so awful for repetitive calls, BUT we can do something called memoisation to hold onto old recursions. this is kind of like how we use hashmaps for 3sum.

3. The fibonacci sequence ramps up really quick.

4. By using u over i for int parses, we can actually check for negatives with Err(_).

My fibonacci code kept getting cooked with high numbers due to memory restrictions but also performance so i had to look up the way to code it properly. because of this, i wanted to include my understanding of how the code works below as its not really my code.

so we want to use HashMaps to store and check the values of each iteration of the fib fn as it will call the same values over and over. we do this by storing it in the memo hashmap and passing that HashMap to the next recursion as well. this means we are constantly updating the hashmap with the values for each N, and then checking them with Option::Some.aka if they exist we don't recalc them. this saves a ton of time and stops our pcs from taking off.

this is just a word thing, but this is just caching right? we're caching our values and then checking them.

kind of a cool way to do it with if let Some(&result) = memo.get(&n)

this means we can put a conditional on the Option::Some enum that we get from .get

turns out that fixed length collections don't return option, but variable length like vecs or HashMaps give us back an Option enum from .get since they can return something but aren't "guaranteed" to.

also if let Some(&result) = memo.get(&n) is just a lowlevel way of saying if memo.get.exists but with destructuring to handle the references from n to result.

im gonna call it right now ownership is going to make my head spin off my shoulders for a long time.

OK THIS IS SO CONFUSING RN IM SURE ITLL MAKE SENSE IN THE FUTURE BUT & BOTH REFERENCES AND DEREFERENCES STUFF. HOW DOES THAT MAKE SENSE.

so this line: let Some(&result) = memo.get(&n)

does all of this:
1. memo does not want us to have ownership of the values it has, since its a greedy bastard. (this is also for performance and safety)
2. .get returns an Option enum kind of. since we are using references (&n) we don't technically have the value, but we have a reference to that value. so the option enum is also going to contain the value within a reference.
3. So now we have a fork where its either Some(reference) or None (this is just null)
4. With our logic it only continues when it is Some, but our Some is a reference value which isn't really that useful for computations.
5. So we DEREFERENCE our reference with &result, which gives us the value from .get without actually taking ownership away from the hashmap.

working with ints in rust is definitely interesting since you can overflow so quickly. even a u128 caps out really quickly in rust, and it makes me want to use BigInt crates. its just so unecessary for this project. i learned a ton about matching and handling parses but tbh i feel like ill forget all this syntax by tomorrow. itll take time and im really enjoying the process so far. i hope i become a good rust coder.

Day 4:

I ended up taking a huge break from this project due to some life stuff, but I am back and hopefully consistent. The goal for now is to start doing 2 "Days" per day to catch up on lost time. This is all within the realm that I can actually understand what I am learning. Today is chapter 4: Ownership.

So they briefly discuss stack and heap here, 1 thing to note is that the data stored on the stack must have a known size (like an array). but data on the heap does not (like a vec). It seems like there's something called an 'allocator' that kind of works like an usher at church. It tries to find memory within the heap to fit you.

Here are some basic rules for ownership:
1. each value in rust has an owner
2. there can only be one owner at a time
3. if it goes out of scope, the value is dropped

.push_str("text"); adds text to the end of a mutable string

so a string literal (&str) is a hardcoded value stored at compiletime, a String is mutable and can grow and shink at runtime.

so unlike C where we need to allocate a variable and then free it, rust returns the memory as soon as a variable is out of scope. this means scope is really important in rust.

AHA here is drop. i knew theyd mention it eventually. p much when a var goes out of scope it calls drop on the var.

okay so copying data on the stack is easy you can just copy it as normal. but if you do something like:

let s1 = String::from("world");
let s2 = s1;

what will happen is s1 will now be invalidated, and s2 will have the pointer, capacity and length of s1. in simple terms it becomes the new owner of that memory.

rust calls this 'moving' rather than 'copying' to differentiate between the two.

to 'copy' a string we must instead .clone it. which is quite performance intensive due to how we handle heap values

if we do something like:

let mut s = String::from("world");
s = String::from("ahoy");

println!("{s}, world!");

it will invalidate or remove the pointer to world and instead set a completely new pntr length and capacity for ahoy. the pointer and capacity and length for world will now be freed and will be 'collected' by drop.

a few notes here about copy and clone, since we know that copy needs the information to be on the stack and not a pointer, we can only copy scalar values like int, bool, char, float, etc.

we can copy arrays and tuples BUT the datatypes within them must also be scalar. aka an array of [1,2,3] is copyable but ['x', 'y'] is not since a string is not scalar. For vecs, since they aren't scalar at all, we can't copy them ever.

okay so some things that can screw us up are here. if we pass a String into a function, we are giving it ownership of that value. that means in the current scope the variable is now out of scope. To keep that value inside of the current scope (not the function scope) we have to clone it first before passing it into the function.

this isnt used rn but the dereferencing operator is *

references can be mutable which allows any operation to be performed on the reference as long as it does not require ownership. aka a &mut String can be .push_str'd

one thing about mutable references is there can only be one at a time.

okay i got a little sidetracked here but i found out something about threads called thread pools. rayon (which is a prelude method? crate? idk) allows us to create a thread pool which queues actions that exceed the maximum threads for parallelism. so if we have 10 tasks and 4 threads itll do 4 tasks, and as soon as one thread finishes, task 5 will start and so on.

data races happen because of the following:

Two or more pointers accessing the same data at the same time
At least one of the pointers is being used to write to the data
Theres no mechanism to synchronise the data

interestingly you can create a block scope which is a scope with no identifier. this can be used to end mut references and many other things. seems pretty useful.

similarly as mentioned before, like how we can't have two mutable references, we also cant have an immutable reference and a mutable reference to the same thing existing at the same time.

there is a bit of a variance here where an immutable reference is only 'active' or 'in scope' when it is being used

if it stops being used, it stops being active. and then we could for instance set a mutable reference. however, if we use the immutable reference after we try and set the mutable reference it will cause an error since the immutable reference is still active.

okay so slices here are a really important type and they seem very powerful. pretty much it allows us to return part of a collection, rather than the entire collection. Also its a reference so it doesnt have ownership.

few small things here, to iterate over a string letter by letter we turn it into bytes using string.as_bytes();

then we can use .iter() to iterate over the array of bytes.

okay this is big and i have no clue how i didnt know this. each letter has an ASCII value associated with it. so 'h' is 104. this means .as_bytes can be used for cryptography. very sick.

.enumerate() wraps the results of .iter() and presumably other things, and returns it as a tuple.

not that b'' is a byte literal, but '' is a char literal.

we create slices within a range by doing this:

let s = String::from("hello world");

let hello = &s[0..5];

this format is &(reference) [starting index...ending index]; to make a slice

a note for rust's range syntax, if ur starting at index 0 you can just drop the 0 and go [..5]

similarly if it goes to the end it can just be [5..]

combining those this is valid: s&[..];

**NOTE slice range indices must be at valid UTF-8 character boundaries** idk what this means but lets just leave it here for now.

&str would return a string slice for instance if it has a range.

note here that &str which is a string literal is actually a reference to a slice. at compiletime the string is turned into binary and we slice that to provide our value. so &str is a reference to a slice of binary.

you can also use &str to kind of cover your ass for &String and &str since &str is a slice already this is something called deref coercion which i don't really get yet but its covered in ch15 or somethin.

OKAY CHAPTER 5 FOR LIKE 12MINS.

Structs. I know you use Structs/enums to do something similar to OOP so this will be interesting.

Okay so structs kind of work like attributes in OOP allowing us to do something like this:

struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

however once important note on the wording is that these are called 'fields' and not 'attributes'

this kind of works like an abstract constructor where we are given these fields but still have to fill them out:

fn main() {
	let user1 = User {
		active: true,
		username: String::from("example123"),
		email: String::from("example@example.com"),
		sign_in_count: 1,
	};
}

a few notes here: a field can be set as optional with Option<data type>
	also a field can be filled with the default value for that data type with ..Default::default.

HOWEVER you cannot define a default value in the struct itself.

we can get the value from a field with dot notation like user1.email
we could also change the value of the field assuming user1 is mut with user1.email = String::from("change");

however for this to work the entire instance must be mutable, not just the field.

we can also make a fn like this that kind of automates the active status and sign_in_count:

fn build_user(email: String, username: String) -> User {
	User {
		active: true,
		username: username,
		email: email,
		sign_in_count: 1,
	}
}

this means that we can just pass in email and username and get a new user like that.

ALSO if the parameter and the field have the same name aka email: email, we can just write, email on that line and it works properly. this means double-naming actually helps us here.

we can also steal the values from another instance very efficiently with .. such as:

let user2 = User {
		email: String::from("anotheruser@example.com")
		..user1
	};

this would be a very efficient way to copy data. but for now that's my time. ONWARDS AND UPWARDS TOMORROW RAH.

Day 5:

okay it is definitely not 'tomorrow' but we press on. i think we are on structs. should finish this + enums today maybe?

like 0% chance we actually get to code anything today right? im thinking that after we get through chapter 8 common collections we start to work on our cli and then return to studying. ah shit ok nvm theres literally a chapter on cli LOL. ok we have to get to chapter 12. so 5/6 today. 7 and MAYBE 8 tomorrow. 9/10 seem fast. then 11 and some of 12. then we finish 12 and work on cli. cli probs takes like 3-5 days ish? since ive decided to pivot from OS dev to blockchain we need to really be studying some blockchain so after the cli we slam it to 20 and then full-send blockchain studying. ideally within the zk snark project of groth 16 1-1 -> halo2 1-1 -> halo2 m-1. then some final zk snark/crypto project for the portfolio then im off to the races.

ok so tuple structs are used to group values under a particular name without needing fields. they are just kind of like a container. the values are also grouped under the custom type defined by the tuple struct's name. each struct you make is its own 'type' right. you can also index these.

you can also make a unit-like struct that doesn't have any fields at all. this is useful mainly for implementing traits on a type.

its written like this btw:

struct TestTester;

no parentheses or curlies.

ok so when making structs you normally want to use standard Strings so that they own the values and are valid while the struct is valid. however you can use &str slices or any other kind of reference as long as you define its 'lifetime'. lifetimes are things covered later, but good to know they exist for now.

okay so here we have an example program. ill write it out to keep up.

fn main() {
	let width1 = 30;
	let height1 = 50;

	println!(
		"The area of the rectangle is {} square pixels.",
		area(width1, height1)
	);
}

fn area(width: u32, height: u32) -> u32 { width * height }

we can convert this into a standard tuple by combining width and height into

let rect1 = (30, 50);

and fn area is -> fn area(dimensions: (u32, u32)) -> u32 { dimensions.0 * dimensions.1 }

now we can use a struct here to define Rectangle which is much clearer:

struct Rectangle {
	width: u32,
	height: u32,
}

fn main() {
	let rect1 = Rectangle {
		width: 30,
		height: 50,
	};

	println!(
		"The area of the rectangle is {} square pixels.",
		area(&rect1)
	);
}

fn area(rectangle: &Rectangle) -> u32 {rectangle.width * rectangle.height }

^^^^^^^^ this is legit just OOP but much cleaner.
Note that when we send rect1 to fn area we use a reference since we wanna keep ownership within the struct.

so some notes here: if we add {:?} inside the curly braces it uses an output format called 'debug'.
debug trait enables us to print out struct in a way thats useful for devs so we can see its value.

to make this work we need to add #[derive(Debug)] to our struct. damn rustc is actually so helpful lmao. the error text is nuts

with larger structs you can also use {:#?} which formats it into a new line for each field.

you can also use dbg! instead of println! but some notes on this. 1. it prints to stderr not stdout. we can also set dbg! in the field itself like so:

width: dbg!(30 * scale),

ok so now we have methods (THIS IS JUST OOP LOL). methods are defined with fn (just like a func), but exist within the context of a struct, enum or trait object.

heres the full code:

#[derive(Debug)]
struct Rectangle {
	width: u32,
	height: u32,
}

impl Rectangle {
	fn area(&self) -> u32 {
		self.width * self.height
	}
}

fn main () {
	let rect1 = Rectangle {
		width: 30,
		height: 50,
	};

	println!(
		"The area of the rectangle is {} square pixels.",
		rect1.area()
	);
}

so to start with we have an impl (implementation block). this turns the fn to a method within the context of the struct. then we ensure the method has &self,
since the parameter typically utilizes self in a method. then when we reference area we can use it as a method syntax such as rect1.area().

within the impl block, the type 'Self' refers as an alias to the type that the impl block is for. in this case, Rectangle.
Typically we call self with &self as a reference. we can sometimes use &mut self and RARELY we use just self. this would only be used when the method transforms self, and we want to prevent the caller from using the original instance.

typically when a method has the same name as a field like:

impl Rectangle {
	fn width(&self) -> u32 {
		self.width
	}
}

we use this as a 'getter'.

note that automatic referencing occurs in methods which keeps code cleaner and removes the need to set mut values on references.

ok now we want some kind of method that checks if it can fit inside anothe rectangle. im gonna try and code this myself.

struct Rectangle {
	width: u32,
	height: u32,
}

impl Rectangle {
	fn can_fit(&self, other: Rectangle) {
		if self.height > other.height && self.width > other.width {
			true
		}
		else { false }
	}
}

something like that?? ok i forgot &Rectangle instead of Rectangle. you can also make it WAY cleaner with the bool setup.

impl Rectangle {
	fn can_fit(&self, other: Rectangle) -> bool {
		self.height > other.height && self.width > other.width {
	}
}

if we don't have self as the first parameter it isnt a method, its an associated function. a very standard way of doing this is with constructors (which we set to the name 'new')

it would be something like this:

impl Rectangle {
	fn square(size: u32) -> Self {
		Self {
			width: size,
			height: size,
		}
	}
}

To call this associated fun we use :: like 

let sq = Rectangle::square(3);. 

also we can have multiple impl blocks. we will find out why thats ever useful in ch10 apparently. dude ch10 has so much lmao.

ok its only been about an hour and id really like to do enums as well but i should sleep. my focus timer also bugged out so its a sign.

Day 6:

Gonna do a short little session on enums today since I've been really bad on this project. Gonna do smaller sessions to try and build good habits.

okay so each enum value can only be one variant or another. it cant be both. so its useful for more selective properties rather than shared properties like a struct would have. mutually exclusive.

you can reference the enum like so:
enum IpAddrKind {
	V4,
	V6,
}

let four = IpAddrKind::V4;
let six = IpAddrKind::V6;

then we can use it in a fn like so:

fn route(ip_kind: IpAddrKind() {}

route(IpAddrKind::V4);

you could use a struct to set a 'kind' and 'address' associations but it makes more sense to do it through a pairing within the enum:


enum IpAddr {
	V4(String),
	V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));

this means that the IpAddr enum has an associated string value.

you can also do differentiation as such:

enum IpAddr {
	V4(u8, u8, u8, u8),
	V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);
let loopback = IpAddr::V6(String::from("::1"));

theres also a std lib for IpAddr, but it sets address data inside a struct:

struct Ipv4Addr {}
struct Ipv6Addr {}

enum IpAddr {
	V4(Ipv4Addr),
	V6(Ipv6Addr),
}

so you can really put any type of data within an enum variant, strings, types, structs or even another enum. so like...cascading enums?

im really interested in learning about vecs but holy god the syntax looks so awful lmao

oooh you can have named values in an enum as well like:

enum Message {
	Quit,
	Move { x: i32, y: i32 }.
}

so afaik, match lets you (forces you) to access all the points in an enum (above would be quit and move). if let accesses one (so just move, or even just x), or you can use a fn to do some kind of custom return.

Enums also don't 'sort' values into the respective enum. rather they have to be explicitly cast into the correct enum. you could always add handling in an outside block.

okay now we have the std::Option
OH IS THIS SOME() NONE()??

interesting that Rust actually doesn't have null. i guess its just None?

okay its defined as:

enum Option<T> {
	None,
	Some(T),
}

oh its not even std::Option. its legit a prelude that makes sense ngl cuz nulls are pervasive.

example:

let some_number = Some(5);
let some_char = Some('e');

let absent_number: Option<i32> = None;

so some_number would be Option<i32> (i guess thats the default. apprently i32 is the default for all ints in rust)

we can also define a type for None, corresponding to that variable. so absent_number would be Option<i32>

However you cant do this:

let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y;

this is because Option<i8> isn't actually a value. its an enum reference. we need to extract that value if we want to use it.

okay im done with 6.1 today. ill do 6.2 and maybe 6.3 tomorrow who knows.

Day 7:

aight 6.2 time. this is just probably only about match cases since its pretty short. im honestly ok with somethign short cuz i want to make a small little program to nail in these skills anyways.

so match p much cascades and covers all options.

enum Coin {
	Penny,
	Nickel,
	Dime,
	Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
	match coin {
		Coin::Penny => 1,
		Coin::Nickel => 5,
		Coin::Dime => 10,
		Coin::Quarter => 25,
	}
}

so like ifs we have a conditional here, but unlike ifs which need a bool, we can use any type like the Coin enum built above.

you can also add baby fns within the arms with {} like so:

Coin::Penny => {
	println!("Lucky penny!");
	1
}

it seems like we could use matchs to check with Option for null values as well. might be a cleaner way of doing it

like fn plus_one(x: Option<i32>) -> Option<i32> {
	match x {
		None => None,
		Some(i) => Some(i + 1),
	}
}

okay if let is even shorter so lets finish this as well before we start working.

if let (like i said before) is mainly for one option, or one arm without having to exhaustively go throught them all.

okok im done with this. its pretty easy to understand but the syntax needs implementation to make sense fully. time to make something.

okay so going through my project a few things so far:

1. let loop and let match are SO NICE. returning values from these makes a lot of sense and helps with some intialization issues.
2. you can use .retain on a vec to remove a particular value kind of like a find and remove but for 1 thing.
3. returning to let match...so before i had a 'choice' var that i wanted to keep track of for another if. so i initialized it at the start of a loop,
but since the loop had an io::stdin after it and that can panic, it saw the choice var as being possibly out of scope. idfk how to fix it other than placing it
below. but that felt ugly. so instead just use a let choice : i8 = match and ur off to the races. its very nice.
4. When using io inputs for traits..? OH ITS FIELDS. Ok for using an input for fields its better to use .trim().to_string() rather than String::From.

Day 8:

I finished my program this morning and decided to do some leetcode. I shoulda been keeping track of what i learned so far but wtv. I'm gonna do it for the like last 10 mins im working on this lol.

if u wanna check length of string you can use string.chars().count()

you can use .max() to keep the max of two values so like:

let x = 1.max(2);

vecs are honestly kinda goated even if the syntax is weird. you can insert into x index with .insert as follows:

vec.insert(index, value);

ok so optimizing that took almost 8 hours. some takeaways here:

when working with linked lists it seems pretty standard to set head to the node, and then set current to a ref to head.

that makes it so that you can 'save' head, but continue working with the current node after that without pushing head out of scope. its super convoluted but just trust that this is the best way to do it.

while .is_some() seems to be a pretty useful and powerful tool for handling enum operations, but its also just super value for casting things into Option and then using it like that. I cant think of great uses right now cuz its almsot 6 am but yeah it seems really good.

linked-lists in general are awful in rust by the way. im sure at some point they will make sense but right now the way they handle ownership is so awful. for instance lets look at this:

if let Some(mut node) = l1_mut {
	temp += node.val;
	l1_mut = node.next.take();
}

the main reason behind this is due to how Rust handles node hopping.

so the if let Some(mut node) = l1_mut works to unwrap the l1_mut.

p much l1_mut is an Option<Box<Node>> and we need to remove the Option part. so we check if it is Some or None.

'If' it is Some, then we want to remove the Option enum and just get the Box<Node>. we are doing this by creating a new var just like in a for loop. we also want that var to be mutable so its mut node.

so this is the syntax for if let Some:

if other side of '=' is Some, let (thing inside paranthesis) be the value within Some.

the important thing though is in the final line where we "take" the .next which is the link between nodes.
So from node1 to node2 we NEED to own that link (or take it) so that we can go to node3. this is because if we don't take ownership for 1-2, trying to go into 3 will cause a double ref from 1 and us. so we need to keep cutting off the nodes behind us as we move forward.


Day 9:

Im gonna do some small studying today since im really burnt from last night working on that leetcode problem. gonna refresh myself on ownership and borrowing and maybe study something new. back to leetcode or some kind of a project tomorrow :).

ok im now realizing the ownership chapter is like SUPER basic...but i guess that makes sense.

good reminder that you can only have 1 mut ref to an object until it goes out of scope, or reaches the end of persistence.

also good note that you can have immutable refs to mutable objects. but i dont think you can have mutable refs to immutables.

i do need to remember slices and how to use them. its kind of hard to find a perfect use case, but something like calling for values in range x-y instead of from 0, seems like a good time to use it since it saves iterations. 

i think the syntax is like:

let x = type;
let x_slice = &x[range];

Strings are a bit confusing but like surely i get it by now. We have 'hello' which is a string literal. but to create that we'd need a &str which is a string slice. We could also cast it into a string with String::from but then we have a String which is an owned type unlike the &str ref. so we can modify it.

okay done with ownership for now. gonna go over if lets again.

oh this is smart, you can use if let to create default values if None. that seems like standard practice and a good thing to remember.

ooh you can also use a let else where the syntax is:

so its: let enumvariant(val) = name of enum holder else {};

this lets us take value if enumvariant exists and if it doesnt we do the else.

okok kind of a piddly little study session but its good enough for a day off.

Day 10:

Starting with leetcode today. Learned about .drain()(.count()) which removes all elements from a vec or a HashSet. This combined with .count() returns the number of elements while removing all of them. Pretty useful.

For some binary search stuff you can use i32::MIN and i32::MAX to represent non-real values kind of like placeholders that ensure comparative correctness.

for c in s.chars().skip(1)

above seems to be some super nice syntax to just skip the first iteration. i love that shit.

Day 11:

Oh my days it has been so long since i worked on this. I got carried away with school projects and personal projects to really come back to this. But its time baby.

I will HOPEFULLY be able to do a chapter a day now.

This is ch7 which seems like version control and package management which is super useful but also really short...so lets hope its fast cuz im hungry.

apparently a 'package' can contain multiple binary crates and optionally one library crate.
eventually with a large project we can extract parts into crates that become dependencies. interesting so we kinda export parts of our code to import it.

There's also somethign called 'workspaces' for giga large projects but i won't need that for now.

Module system is:
	Packages: build, test and share crates
	Crates: its jsut modules that produce a library or exe
	Modules and use: Let you control the organization, scope and privacy of paths
	Paths: A way of naming an item, like a struct or fn

So binary crates are kinda what weve been making so far. They have a main and run.
A library crate don't have a main. But they are usually used for functions that are intended to be shared.

When we refer to importing a crate its usually a library crate

library crates are named as lib.rs in the src folder when initing from cargo

you put binary crates in src/bin/ and each file is a seperate binary crate.

IF LOST JUST LOOK AT THIS SHEET FOR FILE CONSTRUCTION ITS SO NICE.

when compiling the compiler first looks at src/main or src/lib for code to compile

we can declare modules which are pretty much directories that contain more files.

so mod garden;
	src/garden.rs
	src/garden/mod.rs

you can also inline ref subdirectories within garden like that. you might need a mod subdirectory first tho.

mods are private (ofc) at the start. to use them in the parent modules you need to pub mod them.
if we want to shorten paths we can do somethign like:
	use crate::garden::vegetables::Asparaus;
and then we can just refer to it as Asparagus moving forward. I wonder how this works if i also wanted to use Potato. Maybe anohter use?

ok so we need the use in addition to the pub mod.

so its kind of like a daisy chain of pub mods to get to the folders we want. tldr if we want the info passed around we make it pub.

in the example they give they cargo new restaurant --lib with the code:

mod front_of_house {
	mod hosting {
		fn add_to_waitlist() {}
		fn seat_at_table() {}
	}

	mod serving {
		fn take_order() {}
		fn serve_order() {}
		fn take_payment() {}
	}
}

here we have cascading mods, but the mods could also have structs, enums, constants, traits or other stuff.

with paths in rust we use :: but that was shown above.

it seems like in general we use absolute paths rather than relative paths. its also like barely more work.

they used a bunch of text to just explain you have to pub everything to get at somethings insides.

info is passed down towards the child, but to pass it back out the entire path backwards must be pubbed.
this lets us tier our security and makes it more modular if not slightly more work.

theres some external learning here for making API crates but honestly idc that much about them right now. im not in a position to work for free.
ok...thats not true i actually am and its good for my portfolio. idk if i could make anything valuable rn tho. maybe when im intermediate or something.

we can use super like a .. in linux cli. so like super::mod takes us back 1 and then to that mod.

we can also pub a struct and then pub its traits to control which parts are seen:

pub struct Breakfast {
	pub toast: String,
	seasonal_fruit: String,
}

here we can access Breakfast struct, and modify the toast, but the seasonal_fruit is a private value so we can't see or modify it.
however we can create 'getters' or other fns that do somethign similar to see this, just like in any other language.

however for an enum if we make the enum pub it makes all variants pub:

pub enum Appetizer {
	Soup,
	Salad,
}

Soup and Salad variants are both pub in that example.

ok this answers my prev question about use paths.
it seems like we could set a use path to like crate::parent::child.
and then when we want to use grandchild we just say: child::grandchild.

this is alot like use std::io and then io::stdin.

apparently 'uses' also have a scope so make sure to define them where theyre needed.

its good practice to always set a use to the parent. so that when we list the child we know we aren't using a local variable.

HOWEVER if we are using structs or enums or other stuff we can just path to what we want. since that will be used similar to a local call.

the only exception to the above is if the two uses share a name like std::fmt and std::io sharing result. then we go to the parent.
another way we can do this is just to make something an as.

so:
use std::fmt::Result;
use std::io::Result as IoResult;

this avoids a compiler error and allows us to keep the short versions of names. PERSONALLY i would never do this cuz its confusing. but you can.

we can also utilize 'pub use' if the fn we want to call requires that import.
were kind of re-exporting the use here because its needed in the code. and with rust you need to deliberately list these connections.

okay you can also nest some imports which is kind of nice. ive used this before but its nice to solidify how it works.

so if we want std::io and std::cmd::Ordering we can do:
use std::cmp::{cmp::Ordering, io}
we can also do something like this. if we want std::io and std::io::Write (we dont wanna type out the whole import each time)

we can do:
use std::io::{self, Write};

this gives us both self, which is just io and Write the child.

if we want ALL the pub items in the path we just * it. so use std::collections::*;

this is very ugly though so be careful with it. (we use it for tests...which are disgusting)


this is a bit confusing but it seems like you only need to ref a mod once. that tells the compiler to include it as long as its found in the right spot.
this is different than include which needs to be used a bunch of times. i think how it works is instead of calling the mod each time, we just ref the initial mod call. i think...

this is all pretty easy to understand. and is something that will be done many many many times in my career so its pretty idiomatic. good to know the 'proper' way tho.

Day 12:

Woah we're already at a dozen thats kinda exciting. Today doing some more documentation reading. I don't think this chapter will be a ton of new stuff BUT its very very useful so we just gotta read it. I wanted to get started on my Solana project today but ran out of time lmao. SURELY TOMORROW.

so this seems to be just about datatypes that are stored on the heap so: vec, string, hashmap.

create vec with v: Vec<T> = Vec::new();
OR
use vec! with let v = vec![1,2,3];
this uses the default for each type so int is i32.

we can also push to the vec just like a queue.

to get elements we can vecname.get(index). this returns Option(&T)
if we do index[2] we 'should' ref it first so &v[2];

big difference here is the return type. if you don't know if the index exists, just use 'get' cuz it returns Option.

we can iterate through a vec the same way as any collection.
for i in &v {}

since vecs only hold one type, if we need to hold a bunch of diff types a good way to do that is to put them inside an enum. then theyre all the same enum.

as i learned before we can make strings with String::new(), String::from('x'), or 'x'.to_string();

yeah i knew this as well but never used it yet. you can add to a string with push_str("x");

can add strings with +. be careful with refs here cuz ownership is lost.

theres a bunch of text here talking about deref coercion but the tldr is that if you have &str and &String, it will most like coerce the types to be compatible.

if we need to combine multiple strings the best format is:

let s = format!("{x}-{y}-{z}");

best way to iterate over a string is with .chars so:

for i in "String".chars() {}

or for b in {String}.bytes() {}
will give us the unicode values

okay HashMap time!
you make a hashmap with:

let mut map = HashMap::new();
NOTE: all types within a HashMap, like a vec, must be the same

when we want to .get(x) from a HashMap. we pass in the key, not the index.

we can also iterate through a HashMap like so:

for (key, value) in &map {}

theres some lifetime stuff here but im gonna ignore it till they explain lifetimes properly.

no duplicate keys. this is kinda standard but good to remember. Its kinda like the keys are a HashSet. so we have to overwrite, or handle accordingly

we can also do something cool with .entry like so:
map.entry(String::from("Yellow")).or_insert(50);

what this does is check if the key "Yellow" exists. if it does, and is empty it adds the value. if its 'full' it does nothing.
if it doesnt, it inserts the key and the value pairing.

dude chapter 10 seems like a huge deal they keep talking about it.

anyways thats p much collections. its really simple since ive worked with all of these before.
ngl this took barely 20mins so i should definitely work more but its late so imma be healthy and sleep. tmrw ill do some more and maybe get up to ch10 done.
also start on my ML project...and my Solana program..haha....surely...u_u

Day 13:

Day 14:

Day 15:

Day 16:

Day 17:

Day 18:

Day 19:

Day 20:

Day 21:

Day 22:

Day 23:

Day 24:

Day 25:

Day 26:

Day 27:

Day 28:

Day 29:

Day 30:

Day 31:

Day 32:

Day 33:

Day 34:

Day 35:

Day 36:

Day 37:

Day 38:

Day 39:

Day 40:

Day 41:

Day 42:

Day 43:

Day 44:

Day 45:

Day 46:

Day 47:

Day 48:

Day 49:

Day 50:

Day 51:

Day 52:

Day 53:

Day 54:

Day 55:

Day 56:

Day 57:

Day 58:

Day 59:

Day 60:

Day 61:

Day 62:

Day 63:

Day 64:

Day 65:

Day 66:

Day 67:

Day 68:

Day 69:

Day 70:

Day 71:

Day 72:

Day 73:

Day 74:

Day 75:

Day 76:

Day 77:

Day 78:

Day 79:

Day 80:

Day 81:

Day 82:

Day 83:

Day 84:

Day 85:

Day 86:

Day 87:

Day 88:

Day 89:

Day 90:

Day 91:

Day 92:

Day 93:

Day 94:

Day 95:

Day 96:

Day 97:

Day 98:

Day 99:

Day 100:
